<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>家庭記帳</title>

  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="theme-color" content="#111827" />

  <script>
    const manifestJSON = {
      "name": "家庭記帳",
      "short_name": "記帳",
      "display": "standalone",
      "start_url": ".",
      "background_color": "#111827",
      "theme_color": "#111827",
      "icons": [{
        "src": "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='512' height='512' viewBox='0 0 24 24' fill='none' stroke='%233b82f6' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M21 12V7H5a2 2 0 0 1 0-4h14v4M3 5v14a2 2 0 0 0 2 2h16v-5M18 12a2 2 0 0 0 0 4h4v-4Z'/%3E%3C/svg%3E",
        "sizes": "512x512",
        "type": "image/svg+xml"
      }]
    };
    const blob = new Blob([JSON.stringify(manifestJSON)], { type: 'application/manifest+json' });
    const manifestLink = document.createElement('link');
    manifestLink.rel = 'manifest';
    manifestLink.href = URL.createObjectURL(blob);
    document.head.appendChild(manifestLink);
  </script>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700;900&display=swap');
    body {
      font-family: 'Noto Sans TC', sans-serif;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      background-color: #111827;
      margin: 0;
      overflow-x: hidden;
    }
    .scrollbar-hide::-webkit-scrollbar { display: none; }
    .animate-in { animation: fadeIn 0.25s ease-out forwards; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(10px);} to { opacity: 1; transform: translateY(0);} }
    @keyframes cursor-blink { 0%,100%{opacity:1} 50%{opacity:0} }
    .animate-cursor { animation: cursor-blink 1s step-end infinite; }
    .safe-bottom { padding-bottom: env(safe-area-inset-bottom); }
    #root { min-height: 100vh; display:flex; flex-direction:column; }
  </style>
</head>

<body class="bg-gray-50 text-gray-900 text-left font-black">
  <div id="root"></div>

  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState } = React;

    const gasUrl = "https://script.google.com/macros/s/AKfycbxJNnUlFXK8NZ9vaIUvRkq8Njy17P3IlETr_AbkCQhycZ2XUbAnaXvd_7QCT5BQR5zCLA/exec";
    
    // 版號同步
    const APP_VERSION = "2026.03.01.PRO.V17.SNAPSHOT";
    const GAS_TARGET_VERSION = "2026.03.01.PRO.V12.SNAPSHOT";

    const DB_NAME = "FamilyAccountingDB";
    const STORE_NAME = "transactions";
    const DB_VERSION = 1;

    function initIndexedDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onerror = (e) => reject("IndexedDB 初始化失敗");
        request.onsuccess = (e) => resolve(e.target.result);
        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            db.createObjectStore(STORE_NAME, { keyPath: "id" });
          }
        };
      });
    }

    async function saveToIndexedDB(data) {
      try {
        const db = await initIndexedDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(STORE_NAME, "readwrite");
          const store = tx.objectStore(STORE_NAME);
          store.clear(); 
          data.forEach(item => store.put(item)); 
          tx.oncomplete = () => resolve();
          tx.onerror = () => reject();
        });
      } catch (e) { console.warn("IndexedDB 儲存失敗", e); }
    }

    async function loadFromIndexedDB() {
      try {
        const db = await initIndexedDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(STORE_NAME, "readonly");
          const store = tx.objectStore(STORE_NAME);
          const request = store.getAll();
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject();
        });
      } catch (e) { console.warn("IndexedDB 讀取失敗", e); return []; }
    }

    const LS = {
      pending: "pending_sync_v23",
      txCache: "local_tx_cache_v23",
      lastSync: "last_sync_time_v23",
      members: "family_member_config_v23",
      deviceToken: "device_token_v1",
      deviceExp: "device_exp_v1",
      pinHashPrefix: "pin_hash_v23_",
      bioCredPrefix: "bio_cred_",
      bioFailPrefix: "bio_fail_v1_", 
      bioLockPrefix: "bio_lock_v1_",
      greetingsCache: "greetings_cache_v1" 
    };

    const CATEGORY_MAP = {
      expense: {
        "食": ["早餐", "午餐", "晚餐", "生鮮食材", "零食/飲料", "外食聚餐", "其他"],
        "衣": ["爸爸服飾", "媽媽服飾", "小孩服飾", "鞋包/配件", "保養/美妝", "其他"],
        "居家": ["房貸", "管理費", "水費", "電費", "瓦斯費", "網路/電信", "家具/家電", "日用品", "房屋稅/地價稅", "其他"],
        "行": ["大眾運輸", "計程車/共享", "加油", "停車費", "保養維修", "牌照/燃料稅", "eTag/過路費", "其他"],
        "教育": ["學校學費", "安親/才藝班", "教材/文具", "童書/玩具", "零用錢", "其他"],
        "娛樂": ["國內旅遊", "國外旅遊", "串流訂閱", "運動健身", "聚會活動", "電影/展覽", "其他"],
        "醫療": ["保健食品", "診所門診", "牙醫/眼科", "醫美", "住院", "其他"],
        "理財": ["股票/ETF", "定期定額", "基金", "儲蓄險", "外匯", "加密貨幣", "其他"],
        "其他": ["保險費", "孝親費", "紅白包", "捐款/贈與", "雜項"]
      },
      income: {
        "收入": ["爸爸薪資", "媽媽薪資", "獎金", "投資收益", "利息", "其他收入"]
      }
    };

    const getParentCat = (catStr) => {
      if (!catStr) return "其他";
      if (catStr.includes('/')) return catStr.split('/')[0];
      const legacyMap = {"餐飲":"食", "交通":"行", "購物":"衣", "住":"居家", "水電":"居家", "育":"教育", "樂":"娛樂", "薪資":"收入", "投資":"理財", "雜項":"其他"};
      return legacyMap[catStr] || "其他";
    };
    const getChildCat = (catStr) => catStr.includes('/') ? catStr.substring(catStr.indexOf('/') + 1) : catStr;

    const BEN_OPTIONS = ["爸爸", "媽媽", "兒子", "其他"];
    const formatBen = (benStr, memberName) => {
      if (!benStr) return "";
      const arr = benStr.split(",").filter(Boolean);
      if (arr.length === 0) return "";
      if (arr.length === 3 && arr.includes("爸爸") && arr.includes("媽媽") && arr.includes("兒子")) return "全家共同";
      if (arr.length === 1 && arr[0] === memberName) return ""; 
      return arr.join("、");
    };

    const safeParse = (raw, fallback) => {
      if (raw === null || raw === "null" || raw === "undefined") return fallback;
      try { const parsed = JSON.parse(raw); return parsed !== null ? parsed : fallback; } catch { return fallback; } 
    };
    const safeArrayLS = (key) => { const raw = localStorage.getItem(key); const v = safeParse(raw, []); return Array.isArray(v) ? v : []; };
    const safeStringLS = (key, fallback="") => { const v = localStorage.getItem(key); return (v === null || v === "null" || v === "undefined") ? fallback : v; };
    const safeNumberLS = (key, fallback=0) => { const v = Number(localStorage.getItem(key)); return Number.isFinite(v) ? v : fallback; };

    const nowStr = () => {
      const d = new Date();
      return `${d.getFullYear()}/${String(d.getMonth()+1).padStart(2,'0')}/${String(d.getDate()).padStart(2,'0')} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
    };

    async function postGAS(payload) {
      const res = await fetch(gasUrl, { method: "POST", headers: { "Content-Type": "text/plain;charset=utf-8" }, body: JSON.stringify(payload) });
      return await res.json();
    }

    const getDeviceToken = () => safeStringLS(LS.deviceToken, "");
    const getDeviceExp = () => safeNumberLS(LS.deviceExp, 0);
    const deviceValid = () => !!(getDeviceToken() && getDeviceExp() && Date.now() < getDeviceExp());
    const setDeviceToken = (t, exp) => { localStorage.setItem(LS.deviceToken, t); localStorage.setItem(LS.deviceExp, String(exp)); };
    const clearDeviceToken = () => { localStorage.removeItem(LS.deviceToken); localStorage.removeItem(LS.deviceExp); };

    async function sha256Base64(str) {
      const enc = new TextEncoder(); const data = enc.encode(str);
      const digest = await crypto.subtle.digest("SHA-256", data);
      const bytes = new Uint8Array(digest); let bin = "";
      for (let i=0;i<bytes.length;i++) bin += String.fromCharCode(bytes[i]);
      return btoa(bin);
    }

    const getBioKey = (name) => `${LS.bioCredPrefix}${name}`;
    const isDeviceBioBound = (name) => !!localStorage.getItem(getBioKey(name));
    const getBioFailKey = (name) => `${LS.bioFailPrefix}${name}`;
    const getBioLockKey = (name) => `${LS.bioLockPrefix}${name}`;
    const getBioFailCount = (name) => safeNumberLS(getBioFailKey(name), 0);
    const setBioFailCount = (name, v) => localStorage.setItem(getBioFailKey(name), String(v));
    const getBioLockedUntil = (name) => safeNumberLS(getBioLockKey(name), 0);
    const setBioLockedUntil = (name, ts) => localStorage.setItem(getBioLockKey(name), String(ts));
    const clearBioFail = (name) => { setBioFailCount(name, 0); setBioLockedUntil(name, 0); };

    const SvgIcon = ({ name, size = 24, className = "" }) => {
      const icons = {
        home: <React.Fragment><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></React.Fragment>,
        pieChart: <React.Fragment><path d="M21.21 15.89A10 10 0 1 1 8 2.83"/><path d="M22 12A10 10 0 0 0 12 2v10z"/></React.Fragment>,
        wallet: <path d="M21 12V7H5a2 2 0 0 1 0-4h14v4M3 5v14a2 2 0 0 0 2 2h16v-5M18 12a2 2 0 0 0 0 4h4v-4Z"/>,
        plus: <path d="M12 5v14m-7-7h14"/>,
        history: <React.Fragment><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/><rect x="8" y="2" width="8" height="4" rx="1" ry="1"/><path d="M9 12h6"/><path d="M9 16h6"/><path d="M9 8h6"/></React.Fragment>,
        chart: <React.Fragment><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/></React.Fragment>,
        search: <React.Fragment><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></React.Fragment>,
        settings: (<React.Fragment><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1Z"/></React.Fragment>),
        logout: <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4m7 14l5-5l-5-5m5 5H9"/>,
        refresh: <React.Fragment><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></React.Fragment>,
        spinner: <path d="M21 12a9 9 0 1 1-6.219-8.56"/>,
        cloudSync: <React.Fragment><path d="M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242"/><path d="M12 12v9"/><path d="m8 17 4 4 4-4"/></React.Fragment>,
        bio: <React.Fragment><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></React.Fragment>,
        close: <path d="M18 6L6 18M6 6l12 12"/>,
        info: <React.Fragment><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></React.Fragment>,
        check: <path d="M20 6L9 17l-5-5"/>,
        edit: <React.Fragment><path d="M12 20h9"/><path d="M16.5 3.5a2.12 2.12 0 0 1 3 3L7 19l-4 1 1-4Z"/></React.Fragment>,
        trash: <React.Fragment><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/></React.Fragment>,
        layers: <React.Fragment><polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></React.Fragment>
      };
      return (
        <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round" className={`shrink-0 aspect-square ${className}`}>
          {icons[name] || <circle cx="12" cy="12" r="10" />}
        </svg>
      );
    };

    const CategorySelectPair = ({ type, parentCat, childCat, onChange }) => {
      const pCats = Object.keys(CATEGORY_MAP[type] || CATEGORY_MAP.expense);
      const safeParentCat = pCats.includes(parentCat) ? parentCat : pCats[0];
      const cCats = CATEGORY_MAP[type][safeParentCat] || CATEGORY_MAP[type][pCats[0]];

      return (
        <div className="flex gap-2">
          <div className="bg-gray-100 p-2 px-3 rounded-xl flex-1 min-w-0 border border-transparent focus-within:border-blue-200 transition-colors">
            <label className="text-[8px] font-black text-blue-500 uppercase block mb-0.5 tracking-widest">主類別</label>
            <select className="w-full bg-transparent border-none outline-none appearance-none font-black text-sm text-gray-800"
              value={safeParentCat} onChange={(e) => onChange(e.target.value, CATEGORY_MAP[type][e.target.value][0])}>
              {pCats.map(p => <option key={p} value={p}>{p}</option>)}
            </select>
          </div>
          <div className="bg-gray-100 p-2 px-3 rounded-xl flex-1 min-w-0 border border-transparent focus-within:border-blue-200 transition-colors">
            <label className="text-[8px] font-black text-blue-500 uppercase block mb-0.5 tracking-widest">子項目</label>
            <select className="w-full bg-transparent border-none outline-none appearance-none font-black text-sm text-gray-800"
              value={childCat} onChange={(e) => onChange(safeParentCat, e.target.value)}>
              {cCats.map(c => <option key={c} value={c}>{c}</option>)}
            </select>
          </div>
        </div>
      );
    };

    const AddTransactionForm = ({ loginUser, onSubmit, isLoading }) => {
      const inputRef = useRef(null);
      const [isFocused, setIsFocused] = useState(false);
      const [isSplit, setIsSplit] = useState(false);
      
      const [formData, setFormData] = useState({
        amount: "", parentCat: "食", childCat: "晚餐", member: loginUser, beneficiary: [loginUser],
        type: "expense", desc: "", parentTitle: "", parentDesc: "", date: ""
      });

      const [subItems, setSubItems] = useState([
        { id: Date.now(), parentCat: "食", childCat: "晚餐", amount: "", desc: "", beneficiary: [loginUser] }
      ]);

      const otherMember = loginUser === "爸爸" ? "媽媽" : "爸爸";

      useEffect(() => { 
        setFormData(prev => ({ ...prev, member: loginUser || prev.member, beneficiary: [loginUser || prev.member] })); 
        setSubItems(prev => prev.map(s => ({...s, beneficiary: [loginUser || prev.member]})));
      }, [loginUser]);

      const handleTypeChange = (newType) => {
        const defaultP = newType === "expense" ? "食" : "收入";
        const defaultC = CATEGORY_MAP[newType][defaultP][0];
        setFormData(prev => ({ ...prev, type: newType, parentCat: defaultP, childCat: defaultC }));
        setSubItems(prev => prev.map(s => ({ ...s, parentCat: defaultP, childCat: defaultC })));
      };

      const toggleBeneficiary = (b) => {
        if (formData.beneficiary.includes(b)) {
           if (formData.beneficiary.length > 1) setFormData({...formData, beneficiary: formData.beneficiary.filter(x => x !== b)});
        } else setFormData({...formData, beneficiary: [...formData.beneficiary, b]});
      };

      const toggleSubBeneficiary = (id, b) => {
        setSubItems(subItems.map(s => {
          if (s.id !== id) return s;
          const newBen = s.beneficiary.includes(b) 
              ? (s.beneficiary.length > 1 ? s.beneficiary.filter(x => x !== b) : s.beneficiary)
              : [...s.beneficiary, b];
          return { ...s, beneficiary: newBen };
        }));
      };

      const totalSplitAmount = useMemo(() => subItems.reduce((acc, curr) => acc + (Number(curr.amount) || 0), 0), [subItems]);

      const renderAmount = () => {
        if (isSplit) return totalSplitAmount === 0 ? "0" : totalSplitAmount.toString();
        const val = formData.amount;
        if (isFocused) return (val === "" || val === "0") ? <span className="text-gray-300 animate-cursor">_</span> : val;
        return (val === "" || val === "0") ? "0" : val;
      };

      const handleAddSubItem = () => {
        const defaultP = formData.type === "expense" ? "食" : "收入";
        const defaultC = CATEGORY_MAP[formData.type][defaultP][0];
        setSubItems([...subItems, { id: Date.now(), parentCat: defaultP, childCat: defaultC, amount: "", desc: "", beneficiary: [formData.member] }]);
      };

      const handleRemoveSubItem = (id) => { if (subItems.length > 1) setSubItems(subItems.filter(s => s.id !== id)); };
      const updateSubItem = (id, updates) => { setSubItems(prev => prev.map(s => s.id === id ? { ...s, ...updates } : s)); };

      const submitForm = () => {
        if (isSplit) {
          const validSubs = subItems.filter(s => Number(s.amount) > 0);
          if (validSubs.length === 0) return;
          const combinedParentDesc = `${formData.parentTitle.trim() || "多筆紀錄"}|||${formData.parentDesc.trim()}`;
          const multipleTxs = validSubs.map(s => ({
            amount: s.amount, category: `${s.parentCat}/${s.childCat}`,
            member: formData.member, beneficiary: s.beneficiary.join(","),
            type: formData.type, desc: s.desc, date: formData.date, parentDesc: combinedParentDesc
          }));
          onSubmit(multipleTxs);
        } else {
          onSubmit([{ ...formData, category: `${formData.parentCat}/${formData.childCat}`, beneficiary: formData.beneficiary.join(",") }]);
        }
      };

      const isSubmitDisabled = isLoading || (isSplit ? totalSplitAmount === 0 : (!formData.amount || formData.amount === "0"));

      return (
        <div className="bg-white p-5 sm:p-6 rounded-[2.5rem] shadow-xl border border-gray-100 animate-in text-center relative font-black pb-8">
          <div className="flex bg-gray-100 p-1.5 rounded-2xl mb-6 text-sm text-gray-500">
            <button onClick={() => handleTypeChange("expense")} className={`flex-1 py-3 rounded-xl transition-all ${formData.type === "expense" ? "bg-white text-red-500 shadow-sm font-black" : ""}`}>支出</button>
            <button onClick={() => handleTypeChange("income")} className={`flex-1 py-3 rounded-xl transition-all ${formData.type === "income" ? "bg-white text-green-500 shadow-sm font-black" : ""}`}>收入</button>
          </div>

          <div className="relative flex flex-col items-center justify-center mb-6 py-2 min-h-[80px] text-gray-800">
            {isSplit && <span className="text-[10px] text-gray-400 uppercase tracking-widest font-black mb-1">自動加總金額</span>}
            <div className="flex items-center justify-center cursor-pointer max-w-full overflow-hidden" onClick={() => !isSplit && inputRef.current?.focus()}>
              <span className="text-2xl font-black text-gray-300 mr-1 mt-2 shrink-0">$</span>
              <div className={`text-5xl font-black text-center min-w-[1.5rem] tracking-tighter truncate transition-colors ${formData.type === "expense" ? "text-red-500" : "text-green-500"}`}>
                {renderAmount()}
              </div>
              {!isSplit && (
                <input ref={inputRef} type="number" inputMode="decimal" className="absolute inset-0 w-full h-full opacity-0 z-10 cursor-pointer font-black"
                  value={formData.amount} onFocus={() => setIsFocused(true)} onBlur={() => setIsFocused(false)} onChange={(e) => setFormData({ ...formData, amount: e.target.value })}
                />
              )}
            </div>
          </div>

          <div className="space-y-4 text-left">
            <div className="bg-gray-100 p-3 rounded-2xl flex items-center justify-between">
              <span className="text-xs font-black text-gray-600 pl-2">拆分多筆明細 (如單張發票)</span>
              <button onClick={() => setIsSplit(!isSplit)} className={`w-12 h-6 shrink-0 rounded-full p-1 transition-colors duration-200 ease-in-out ${isSplit ? 'bg-blue-500' : 'bg-gray-300'}`}>
                <div className={`w-4 h-4 bg-white rounded-full shadow-md transform transition-transform duration-200 ease-in-out ${isSplit ? 'translate-x-6' : 'translate-x-0'}`}></div>
              </button>
            </div>

            <div className="bg-gray-100 py-1.5 px-3 rounded-xl flex items-center justify-between border border-transparent focus-within:border-blue-200 transition-colors">
              <label className="text-[10px] font-black text-gray-400 uppercase tracking-widest shrink-0">時間</label>
              <input type="datetime-local" className="bg-transparent font-black border-none outline-none text-gray-800 text-xs flex-1 text-right min-w-0"
                value={formData.date} onChange={(e) => setFormData({ ...formData, date: e.target.value })} />
            </div>

            {!isSplit && (
              <>
                <div className="bg-gray-50 py-2 px-3 rounded-xl border border-gray-100 flex items-center justify-between">
                  <label className="text-[10px] font-black text-gray-400 uppercase tracking-widest mr-2 shrink-0">對象</label>
                  <div className="flex gap-1.5 flex-1 justify-end flex-wrap">
                    {BEN_OPTIONS.map(b => (
                      <button type="button" key={b} onClick={() => toggleBeneficiary(b)}
                        className={`px-3 py-1 rounded-lg text-[10px] font-black transition-all border ${formData.beneficiary.includes(b) ? "bg-blue-600 border-blue-600 text-white shadow-sm" : "bg-white border-gray-200 text-gray-400 hover:bg-gray-50"}`}>
                        {b}
                      </button>
                    ))}
                  </div>
                </div>
                <CategorySelectPair type={formData.type} parentCat={formData.parentCat} childCat={formData.childCat} onChange={(p, c) => setFormData({ ...formData, parentCat: p, childCat: c })} />
                <div className="bg-gray-100 py-2.5 px-4 rounded-xl border border-transparent focus-within:border-blue-200 transition-colors flex items-center gap-3">
                  <label className="text-[10px] font-black text-gray-400 uppercase tracking-widest shrink-0">備註</label>
                  <input type="text" className="w-full bg-transparent font-bold border-none outline-none text-gray-800 placeholder:text-gray-300 text-sm min-w-0"
                    placeholder="輸入說明..." value={formData.desc} onChange={(e) => setFormData({ ...formData, desc: e.target.value })} />
                </div>
              </>
            )}

            {isSplit && (
              <>
                <div className="flex gap-2">
                  <div className="bg-gray-100 py-2 px-3 rounded-xl flex-1 min-w-0 focus-within:border-blue-200 border border-transparent transition-colors">
                    <label className="text-[8px] font-black text-gray-400 uppercase block mb-0.5 tracking-widest">母項目標題</label>
                    <input type="text" className="w-full bg-transparent font-black border-none outline-none text-gray-800 placeholder:text-gray-300 text-xs min-w-0"
                      placeholder="如：全聯發票" value={formData.parentTitle} onChange={(e) => setFormData({ ...formData, parentTitle: e.target.value })} />
                  </div>
                  <div className="bg-gray-100 py-2 px-3 rounded-xl flex-1 min-w-0 focus-within:border-blue-200 border border-transparent transition-colors">
                    <label className="text-[8px] font-black text-gray-400 uppercase block mb-0.5 tracking-widest">母項目備註</label>
                    <input type="text" className="w-full bg-transparent font-bold border-none outline-none text-gray-800 placeholder:text-gray-300 text-xs min-w-0"
                      placeholder="選填..." value={formData.parentDesc} onChange={(e) => setFormData({ ...formData, parentDesc: e.target.value })} />
                  </div>
                </div>

                <div className="space-y-3 pt-2 border-t border-gray-100">
                  <label className="text-[10px] font-black text-blue-500 uppercase block tracking-widest px-2">子項目明細與花費對象</label>
                  {subItems.map((sub, index) => {
                    const pCats = Object.keys(CATEGORY_MAP[formData.type] || CATEGORY_MAP.expense);
                    const safeParentCat = pCats.includes(sub.parentCat) ? sub.parentCat : pCats[0];
                    const cCats = CATEGORY_MAP[formData.type][safeParentCat] || CATEGORY_MAP[formData.type][pCats[0]];
                    return (
                      <div key={sub.id} className="bg-white border-2 border-gray-100 p-3 rounded-2xl relative shadow-sm">
                        {subItems.length > 1 && (
                          <button onClick={() => handleRemoveSubItem(sub.id)} className="absolute -top-2 -right-2 bg-red-100 text-red-600 w-6 h-6 rounded-full flex items-center justify-center text-xs shadow-sm font-bold">✕</button>
                        )}
                        <div className="flex gap-2 mb-2">
                          <select className="flex-1 min-w-0 bg-gray-50 border-none outline-none appearance-none font-black text-xs px-2 py-2 rounded-xl text-gray-700"
                            value={safeParentCat} onChange={(e) => { const newP = e.target.value; updateSubItem(sub.id, {parentCat: newP, childCat: CATEGORY_MAP[formData.type][newP][0]}); }}>
                            {pCats.map(c => <option key={c} value={c}>{c}</option>)}
                          </select>
                          <select className="flex-1 min-w-0 bg-gray-50 border-none outline-none appearance-none font-black text-xs px-2 py-2 rounded-xl text-gray-700"
                            value={sub.childCat} onChange={(e) => updateSubItem(sub.id, {childCat: e.target.value})}>
                            {cCats.map(c => <option key={c} value={c}>{c}</option>)}
                          </select>
                        </div>
                        <div className="flex gap-2 mb-2 items-center">
                          <input type="text" className="flex-[3] min-w-0 bg-gray-50 font-bold border-none outline-none text-gray-800 placeholder:text-gray-400 text-xs px-2.5 py-2 rounded-xl"
                            placeholder="子項備註(選填)" value={sub.desc} onChange={(e) => updateSubItem(sub.id, {desc: e.target.value})} />
                          <div className="flex-[2] min-w-0 relative">
                            <span className="absolute left-2 top-1/2 -translate-y-1/2 text-gray-400 font-black text-xs">$</span>
                            <input type="number" inputMode="decimal" className="w-full bg-blue-50/50 font-black border-none outline-none text-blue-800 placeholder:text-blue-300 text-sm pl-5 pr-2 py-2 rounded-xl text-right min-w-0"
                              placeholder="0" value={sub.amount} onChange={(e) => updateSubItem(sub.id, {amount: e.target.value})} />
                          </div>
                        </div>
                        <div className="flex items-center justify-between pt-1">
                          <span className="text-[9px] font-bold text-gray-400 uppercase pr-2 shrink-0">對象</span>
                          <div className="flex gap-1 flex-1 justify-end flex-wrap">
                            {BEN_OPTIONS.map(b => (
                              <button type="button" key={b} onClick={() => toggleSubBeneficiary(sub.id, b)}
                                className={`px-2 py-1 rounded-md text-[9px] font-black transition-all border ${sub.beneficiary.includes(b) ? "bg-blue-600 border-blue-600 text-white" : "bg-white border-gray-200 text-gray-400"}`}>
                                {b}
                              </button>
                            ))}
                          </div>
                        </div>
                      </div>
                    )
                  })}
                  <button onClick={handleAddSubItem} className="w-full py-3 bg-blue-50 text-blue-600 rounded-xl font-black text-xs active:scale-95 transition flex justify-center items-center gap-1 border border-blue-100">
                    <SvgIcon name="plus" size={16} /> 新增子項目
                  </button>
                </div>
              </>
            )}

            <div className="bg-gray-50 py-2.5 px-4 rounded-2xl border border-gray-100 flex items-center justify-between">
              <label className="text-[10px] font-black text-gray-400 uppercase tracking-widest shrink-0 mr-2">記錄帳本</label>
              <div className="flex gap-1.5 flex-wrap justify-end">
                <button type="button" onClick={() => setFormData({ ...formData, member: loginUser })} className={`px-4 py-1.5 rounded-lg text-[10px] transition-all border-2 font-black ${formData.member === loginUser ? "bg-gray-800 border-gray-800 text-white" : "bg-white border-gray-200 text-gray-400"}`}>自己</button>
                <button type="button" onClick={() => setFormData({ ...formData, member: otherMember })} className={`px-4 py-1.5 rounded-lg text-[10px] transition-all border-2 font-black ${formData.member === otherMember ? "bg-gray-800 border-gray-800 text-white" : "bg-white border-gray-200 text-gray-400"}`}>幫{otherMember}記</button>
              </div>
            </div>
          </div>

          <button disabled={isSubmitDisabled} onClick={submitForm}
            className="w-full mt-8 py-5 bg-blue-600 text-white rounded-3xl font-black text-lg active:scale-95 transition shadow-xl shadow-blue-500/30 disabled:opacity-40 disabled:shadow-none flex justify-center items-center gap-2"
          >
            {isLoading ? <SvgIcon name="spinner" size={20} className="animate-spin" /> : null}
            {isLoading ? "處理中..." : (isSplit ? `確認存檔 (${subItems.length}筆)` : "確認存檔")}
          </button>
        </div>
      );
    };

    const EditTransactionModal = ({ tx, loginUser, onSave, onDelete, onCancel, isLoading }) => {
      const [formData, setFormData] = useState({ 
        ...tx, parentCat: getParentCat(tx.category), childCat: getChildCat(tx.category),
        beneficiary: tx.beneficiary ? tx.beneficiary.split(",").filter(Boolean) : [tx.member]
      });
      const [showConfirmDelete, setShowConfirmDelete] = useState(false);

      useEffect(() => {
        let formattedDate = "";
        if (tx.date) {
          formattedDate = String(tx.date).replace(" (已編輯)", "").replace("(已編輯)", "").replace(/\//g, "-").replace(" ", "T");
          if (formattedDate.length > 16) formattedDate = formattedDate.slice(0, 16);
        }
        setFormData(prev => ({ ...prev, date: formattedDate }));
      }, [tx]);

      const otherMember = loginUser === "爸爸" ? "媽媽" : "爸爸";

      const toggleBeneficiary = (b) => {
        if (formData.beneficiary.includes(b)) {
           if (formData.beneficiary.length > 1) setFormData({...formData, beneficiary: formData.beneficiary.filter(x => x !== b)});
        } else setFormData({...formData, beneficiary: [...formData.beneficiary, b]});
      };

      const handleSave = () => onSave({ ...formData, category: `${formData.parentCat}/${formData.childCat}`, beneficiary: formData.beneficiary.join(",") });

      return (
        <div className="fixed inset-0 z-[500] bg-gray-900/90 backdrop-blur-sm overflow-y-auto flex flex-col items-center justify-center p-4 sm:p-6 animate-in font-black" onClick={(e) => { if(e.target === e.currentTarget) onCancel(); }}>
          <div className="w-full max-w-sm relative">
            <button onClick={onCancel} className="absolute -top-12 right-0 text-white p-2 active:scale-90 opacity-80 hover:opacity-100 transition"><SvgIcon name="close" size={32} /></button>
            <div className="bg-white p-5 sm:p-6 rounded-[2.5rem] shadow-2xl relative overflow-hidden pb-8">
              <div className="absolute top-0 left-0 w-full h-2 bg-blue-500"></div>
              <h2 className="text-xl font-black text-center mb-6 text-gray-800 pt-2">編輯明細</h2>

              <div className="flex bg-gray-100 p-1.5 rounded-2xl mb-6 text-sm text-gray-500">
                <button onClick={() => { const p = "食"; const c = CATEGORY_MAP["expense"][p][0]; setFormData({ ...formData, type: "expense", parentCat: p, childCat: c }) }} className={`flex-1 py-3 rounded-xl transition-all ${formData.type === "expense" ? "bg-white text-red-500 shadow-sm font-black" : ""}`}>支出</button>
                <button onClick={() => { const p = "收入"; const c = CATEGORY_MAP["income"][p][0]; setFormData({ ...formData, type: "income", parentCat: p, childCat: c }) }} className={`flex-1 py-3 rounded-xl transition-all ${formData.type === "income" ? "bg-white text-green-500 shadow-sm font-black" : ""}`}>收入</button>
              </div>

              <div className="relative flex items-center justify-center mb-6 py-2 border-b border-gray-100 pb-6 text-gray-800 max-w-full overflow-hidden">
                <span className="text-2xl font-black text-gray-300 mr-1 mt-1 shrink-0">$</span>
                <input type="number" inputMode="decimal" className={`w-[120px] max-w-full text-4xl sm:text-5xl font-black text-center outline-none bg-transparent min-w-0 ${formData.type === "expense" ? "text-red-500" : "text-green-500"}`}
                  value={formData.amount} onChange={(e) => setFormData({ ...formData, amount: e.target.value })} />
              </div>

              <div className="space-y-4 text-left">
                <div className="bg-gray-100 py-1.5 px-3 rounded-xl flex items-center justify-between border border-transparent focus-within:border-blue-200 transition-colors">
                  <label className="text-[10px] font-black text-gray-400 uppercase tracking-widest shrink-0">時間</label>
                  <input type="datetime-local" className="bg-transparent font-black border-none outline-none text-gray-800 text-xs w-[140px] md:w-[160px] text-right min-w-0"
                    value={formData.date} onChange={(e) => setFormData({ ...formData, date: e.target.value })} />
                </div>

                <div className="bg-gray-50 py-2 px-3 rounded-xl border border-gray-100 flex items-center justify-between">
                  <label className="text-[10px] font-black text-gray-400 uppercase tracking-widest mr-2 shrink-0">對象</label>
                  <div className="flex gap-1.5 flex-1 justify-end flex-wrap">
                    {BEN_OPTIONS.map(b => (
                      <button type="button" key={b} onClick={() => toggleBeneficiary(b)}
                        className={`px-3 py-1 rounded-lg text-[10px] font-black transition-all border ${formData.beneficiary.includes(b) ? "bg-blue-600 border-blue-600 text-white shadow-sm" : "bg-white border-gray-200 text-gray-400 hover:bg-gray-50"}`}>
                        {b}
                      </button>
                    ))}
                  </div>
                </div>

                <CategorySelectPair type={formData.type} parentCat={formData.parentCat} childCat={formData.childCat} onChange={(p, c) => setFormData({ ...formData, parentCat: p, childCat: c })} />

                <div className="bg-gray-100 py-2 px-3 rounded-xl border border-transparent focus-within:border-blue-200 transition-colors flex items-center gap-3">
                  <label className="text-[10px] font-black text-gray-400 uppercase tracking-widest shrink-0">帳本</label>
                  <select className="w-full bg-transparent border-none outline-none appearance-none font-black text-sm text-right min-w-0"
                    value={formData.member} onChange={(e) => setFormData({ ...formData, member: e.target.value })}>
                    <option value={loginUser}>自己</option><option value={otherMember}>{otherMember}</option>
                  </select>
                </div>

                <div className="bg-gray-100 py-2 px-3 rounded-xl border border-transparent focus-within:border-blue-200 transition-colors flex items-center gap-3">
                  <label className="text-[10px] font-black text-gray-400 uppercase tracking-widest shrink-0">備註</label>
                  <input type="text" className="w-full bg-transparent font-bold border-none outline-none text-gray-800 placeholder:text-gray-300 text-sm text-right min-w-0"
                    placeholder="選填" value={formData.desc} onChange={(e) => setFormData({ ...formData, desc: e.target.value })} />
                </div>
              </div>

              <div className="flex gap-3 mt-8">
                {!showConfirmDelete ? (
                  <>
                    <button disabled={isLoading} onClick={() => setShowConfirmDelete(true)} className="flex-1 py-4 bg-red-50 text-red-600 rounded-2xl font-black active:scale-95 transition-all flex items-center justify-center gap-1 disabled:opacity-30">
                      <SvgIcon name="trash" size={18} /> 刪除
                    </button>
                    <button disabled={!formData.amount || formData.amount === "0" || isLoading} onClick={handleSave} className="flex-[2] py-4 bg-blue-600 text-white rounded-2xl font-black active:scale-95 transition-all shadow-lg shadow-blue-500/30 disabled:opacity-30 flex justify-center items-center gap-2">
                      {isLoading ? <SvgIcon name="spinner" size={16} className="animate-spin" /> : null} {isLoading ? "處理中..." : "儲存變更"}
                    </button>
                  </>
                ) : (
                  <div className="w-full animate-in bg-red-50 p-4 rounded-2xl text-center border border-red-100">
                    <p className="text-red-600 font-black text-xs mb-3">確定永久刪除此紀錄？</p>
                    <div className="flex gap-2 flex-wrap">
                      <button onClick={() => setShowConfirmDelete(false)} className="flex-1 min-w-[100px] py-3 bg-white text-gray-600 rounded-xl font-black active:scale-95 border border-gray-200">保留</button>
                      <button disabled={isLoading} onClick={() => onDelete(tx.id)} className="flex-1 min-w-[100px] py-3 bg-red-600 text-white rounded-xl font-black active:scale-95 shadow-md shadow-red-500/20 disabled:opacity-30">確認刪除</button>
                    </div>
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>
      );
    };

    const EditGroupParentModal = ({ group, onSave, onCancel, isLoading }) => {
      const [formData, setFormData] = useState({ parentTitle: group.parentTitle, parentDesc: group.parentDesc, date: group.date });

      useEffect(() => {
        let formattedDate = "";
        if (group.date) {
          formattedDate = String(group.date).replace(" (已編輯)", "").replace("(已編輯)", "").replace(/\//g, "-").replace(" ", "T");
          if (formattedDate.length > 16) formattedDate = formattedDate.slice(0, 16);
        }
        setFormData(prev => ({ ...prev, date: formattedDate }));
      }, [group]);

      const handleSave = () => {
        const combinedParentDesc = `${formData.parentTitle.trim() || "拆分紀錄"}|||${formData.parentDesc.trim()}`;
        onSave({ groupId: group.groupId, parentDesc: combinedParentDesc, date: formData.date });
      };

      return (
        <div className="fixed inset-0 z-[500] bg-gray-900/90 backdrop-blur-sm overflow-y-auto flex flex-col items-center justify-center p-4 sm:p-6 animate-in font-black" onClick={(e) => { if(e.target === e.currentTarget) onCancel(); }}>
          <div className="w-full max-w-sm relative">
            <button onClick={onCancel} className="absolute -top-12 right-0 text-white p-2 active:scale-90 opacity-80 hover:opacity-100 transition">
              <SvgIcon name="close" size={32} />
            </button>
            <div className="bg-white p-5 sm:p-6 rounded-[2.5rem] shadow-2xl relative overflow-hidden pb-8">
              <div className="absolute top-0 left-0 w-full h-2 bg-gray-800"></div>
              <h2 className="text-xl font-black text-center mb-2 text-gray-800 pt-2">編輯母項目</h2>
              <p className="text-[10px] text-gray-400 text-center mb-6">修改後將同步更新旗下所有明細的時間與標題</p>

              <div className="space-y-4 text-left">
                <div className="bg-gray-100 py-2.5 px-4 rounded-xl flex items-center justify-between border border-transparent focus-within:border-gray-300 transition-colors">
                  <label className="text-[10px] font-black text-gray-400 uppercase tracking-widest shrink-0">時間</label>
                  <input type="datetime-local" className="bg-transparent font-black border-none outline-none text-gray-800 text-sm flex-1 text-right min-w-0"
                    value={formData.date} onChange={(e) => setFormData({ ...formData, date: e.target.value })} />
                </div>
                <div className="bg-gray-100 py-3 px-4 rounded-xl flex flex-col gap-1 border border-transparent focus-within:border-gray-300 transition-colors">
                  <label className="text-[10px] font-black text-gray-400 uppercase tracking-widest shrink-0">母項目標題</label>
                  <input type="text" className="w-full bg-transparent font-black border-none outline-none text-gray-800 placeholder:text-gray-300 text-sm min-w-0"
                    placeholder="如：全聯發票" value={formData.parentTitle} onChange={(e) => setFormData({ ...formData, parentTitle: e.target.value })} />
                </div>
                <div className="bg-gray-100 py-3 px-4 rounded-xl flex flex-col gap-1 border border-transparent focus-within:border-gray-300 transition-colors">
                  <label className="text-[10px] font-black text-gray-400 uppercase tracking-widest shrink-0">母項目備註</label>
                  <input type="text" className="w-full bg-transparent font-bold border-none outline-none text-gray-800 placeholder:text-gray-300 text-sm min-w-0"
                    placeholder="選填" value={formData.parentDesc} onChange={(e) => setFormData({ ...formData, parentDesc: e.target.value })} />
                </div>
              </div>

              <div className="mt-8">
                <button disabled={isLoading} onClick={handleSave} className="w-full py-4 bg-gray-800 text-white rounded-2xl font-black active:scale-95 transition-all shadow-lg disabled:opacity-30 flex justify-center items-center gap-2">
                  {isLoading ? <SvgIcon name="spinner" size={16} className="animate-spin" /> : null} {isLoading ? "處理中..." : "批次更新所有子項目"}
                </button>
              </div>
            </div>
          </div>
        </div>
      );
    };

    function App() {
      const [activeTab, setActiveTab] = useState("dashboard");
      const [familyConfig, setFamilyConfig] = useState(() => {
        const saved = safeArrayLS(LS.members); return saved.length ? saved : [{ name: "爸爸", color: "bg-blue-600" }, { name: "媽媽", color: "bg-pink-600" }];
      });
      const [customSubtitle, setCustomSubtitle] = useState("{name}，你好！");
      const [greetingsCache, setGreetingsCache] = useState(() => {
        const raw = localStorage.getItem(LS.greetingsCache);
        if (!raw || raw === "null" || raw === "undefined") return {};
        try { return JSON.parse(raw) || {}; } catch { return {}; }
      });

      const [currentUser, setCurrentUser] = useState(null);
      const [selectingUser, setSelectingUser] = useState(null);
      const [pinInput, setPinInput] = useState("");
      
      const [fallbackToPin, setFallbackToPin] = useState(false);
      
      // 【防呆鎖定】防止使用者連續點擊多次生物辨識
      const [isAuthenticating, setIsAuthenticating] = useState(false);

      const [biometricAvailable, setBiometricAvailable] = useState(false);
      const [isLoading, setIsLoading] = useState(false);
      const [statusMsg, setStatusMsg] = useState({ type: "", text: "" });
      const [loadingCard, setLoadingCard] = useState({ show: false, text: "" });

      const [showClearQueueModal, setShowClearQueueModal] = useState(false);
      
      // 【快照視窗狀態】
      const [historyModalText, setHistoryModalText] = useState("");

      const [lastSyncText, setLastSyncText] = useState(() => safeStringLS(LS.lastSync, "----/--/-- --:--"));
      
      const [txCache, setTxCache] = useState(() => safeArrayLS(LS.txCache));
      const [transactions, setTransactions] = useState(() => safeArrayLS(LS.txCache));
      const [syncQueue, setSyncQueue] = useState(() => safeArrayLS(LS.pending));

      const [editingTx, setEditingTx] = useState(null);
      const [editingGroup, setEditingGroup] = useState(null);
      const [editingIsPending, setEditingIsPending] = useState(false);

      const [expandedGroups, setExpandedGroups] = useState({});
      
      const [historySearch, setHistorySearch] = useState("");
      const [debouncedHistorySearch, setDebouncedHistorySearch] = useState(""); 
      const [historyTypeFilter, setHistoryTypeFilter] = useState("all");
      const [historyDateFilter, setHistoryDateFilter] = useState("all");
      const [historyVisibleCount, setHistoryVisibleCount] = useState(20);
      
      const [analysisDateFilter, setAnalysisDateFilter] = useState("1m");
      const [analysisCustomStart, setAnalysisCustomStart] = useState("");
      const [analysisCustomEnd, setAnalysisCustomEnd] = useState("");
      const [analysisType, setAnalysisType] = useState("expense"); 
      const [selectedAnalysisLevel1, setSelectedAnalysisLevel1] = useState(null); 
      const [selectedAnalysisLevel2, setSelectedAnalysisLevel2] = useState(null); 

      const [showBootstrapModal, setShowBootstrapModal] = useState(false);
      const [bootstrapSecret, setBootstrapSecret] = useState("");
      const [showUnbindModal, setShowUnbindModal] = useState(false);
      const [unbindPin, setUnbindPin] = useState("");
      const [showChangePinModal, setShowChangePinModal] = useState(false);
      const [oldPin, setOldPin] = useState("");
      const [newPin, setNewPin] = useState("");
      const [newPin2, setNewPin2] = useState("");
      const [isLogOpen, setIsLogOpen] = useState(false);

      const [isOnline, setIsOnline] = useState(navigator.onLine);

      const showStatus = (type, text) => { setStatusMsg({ type, text }); setTimeout(() => setStatusMsg({ type: "", text: "" }), 3000); };

      useEffect(() => {
        const handleOnline = () => { setIsOnline(true); showStatus("success", "網路已恢復連線"); };
        const handleOffline = () => { setIsOnline(false); showStatus("info", "已進入離線模式"); };
        window.addEventListener('online', handleOnline);
        window.addEventListener('offline', handleOffline);
        return () => {
          window.removeEventListener('online', handleOnline);
          window.removeEventListener('offline', handleOffline);
        };
      }, []);

      useEffect(() => localStorage.setItem(LS.pending, JSON.stringify(syncQueue)), [syncQueue]);
      useEffect(() => localStorage.setItem(LS.members, JSON.stringify(familyConfig)), [familyConfig]);
      useEffect(() => localStorage.setItem(LS.lastSync, lastSyncText), [lastSyncText]);
      useEffect(() => localStorage.setItem(LS.greetingsCache, JSON.stringify(greetingsCache || {})), [greetingsCache]);

      useEffect(() => {
        loadFromIndexedDB().then(idbData => {
          if (idbData && idbData.length > 0) {
            setTxCache(idbData);
            if (!isOnline) setTransactions(idbData);
          }
        });
      }, [isOnline]);

      useEffect(() => {
        if (currentUser && greetingsCache && greetingsCache[currentUser.name]) {
           setCustomSubtitle(greetingsCache[currentUser.name]);
        } else if (currentUser) {
           setCustomSubtitle("{name}，你好！");
        }
      }, [currentUser, greetingsCache]);

      useEffect(() => {
        const timer = setTimeout(() => setDebouncedHistorySearch(historySearch), 350);
        return () => clearTimeout(timer);
      }, [historySearch]);

      useEffect(() => setHistoryVisibleCount(20), [debouncedHistorySearch, historyTypeFilter, historyDateFilter, activeTab]);
      useEffect(() => { if (activeTab !== "analysis") { setSelectedAnalysisLevel1(null); setSelectedAnalysisLevel2(null); setAnalysisType("expense"); } }, [activeTab]);
      useEffect(() => { setSelectedAnalysisLevel1(null); setSelectedAnalysisLevel2(null); }, [analysisType, analysisDateFilter, analysisCustomStart, analysisCustomEnd]); 
      useEffect(() => { setSelectedAnalysisLevel2(null); }, [selectedAnalysisLevel1]); 

      useEffect(() => { if (window.PublicKeyCredential) PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable().then(v => setBiometricAvailable(v)); }, []);
      useEffect(() => { (async () => { try { const res = await fetch(gasUrl); const data = await res.json(); if (data.members && data.members.length) setFamilyConfig(data.members); } catch {} })(); }, []);
      
      useEffect(() => { if (isOnline && !deviceValid()) { setShowBootstrapModal(true); setBootstrapSecret(""); } }, [isOnline]);

      useEffect(() => {
        if (isOnline && currentUser && syncQueue.length > 0) {
          processQueueToCloud({ doRefreshFirst: true });
        }
      }, [isOnline, currentUser]);

      const displayDateClean = (val) => {
        if (!val) return "";
        let str = String(val).replace(/上午|下午|AM|PM/gi, "").trim().replace(/-/g, "/").replace("T", " ");
        const parts = str.split(" ");
        return parts.length > 1 ? `${parts[0]} ${parts[1].split(":").slice(0,2).join(":")}` : str;
      };

      const forceReloginForToken = () => { setTimeout(() => { setCurrentUser(null); setSelectingUser(null); setPinInput(""); setBootstrapSecret(""); setShowBootstrapModal(true); }, 2000); };

      const refreshDeviceToken = async () => {
        const data = await postGAS({ action: "DEVICE_REFRESH", deviceToken: getDeviceToken() });
        if (data.result !== "success") throw new Error(data.message || "憑證已過期");
        setDeviceToken(data.deviceToken, data.deviceExp); return data;
      };

      const bootstrapDevice = async () => {
        if (!bootstrapSecret) throw new Error("請輸入雲端密碼");
        const data = await postGAS({ action: "DEVICE_BOOTSTRAP", appSecret: bootstrapSecret });
        if (data.result !== "success") throw new Error(data.message || "綁定失敗");
        setDeviceToken(data.deviceToken, data.deviceExp); return data;
      };

      const verifyPinOnline = async (name, pin) => {
        const res = await postGAS({ action:"VERIFY_PIN", name, pin, deviceToken: getDeviceToken() });
        if (res.result !== "success") throw new Error(res.message || "PIN 錯誤"); return true;
      };

      const fetchCloudTx = async () => {
        const data = await postGAS({ action:"GET_TX", deviceToken: getDeviceToken() });
        if (data.result !== "success") throw new Error(data.message || "抓取失敗");
        const formatted = (data.transactions || []).map((t, i) => {
          const rawDate = t["日期時間"] || t["日期"] || "";
          const cleanStr = String(rawDate).replace(/上午|下午|AM|PM/gi, "").trim().replace(/-/g, "/").replace("T", " ");
          const ts = new Date(cleanStr).getTime() || 0;
          return {
            id: t.id || t["ID"] || String(i), amount: parseFloat(t["金額"]) || 0, category: t["類別"] || "其他",
            date: rawDate, timestamp: ts, member: t["成員"] || "未知", recorder: t["記錄者"] || "系統",
            desc: t["備註"] || "", type: t["類型"] || "expense", groupId: t["GroupID"] || "", parentDesc: t["ParentDesc"] || "", beneficiary: t["Beneficiary"] || "",
            editHistory: t["EditHistory"] || "" // 【快照讀取】
          };
        });
        setTransactions(formatted); 
        setTxCache(formatted); 
        setLastSyncText(nowStr()); 
        if (data.greetings) setGreetingsCache(data.greetings); 

        saveToIndexedDB(formatted);
        localStorage.setItem(LS.txCache, JSON.stringify(formatted));

        return formatted;
      };

      const processQueueToCloud = async ({ doRefreshFirst, isLoginSync = false }) => {
        if (!isOnline) return true;
        if (!deviceValid()) { 
           showStatus("error", "雲端憑證已過期，請重新綁定"); 
           forceReloginForToken(); 
           return false; 
        }
        try {
          if (doRefreshFirst) await refreshDeviceToken();
          
          if (isLoginSync) setLoadingCard({ show: true, text: "登入成功，正在下載最新帳本..." });
          else if (syncQueue.length > 0) setLoadingCard({ show: true, text: "正在同步暫存..." });

          let didWrite = false;
          if (syncQueue.length > 0) {
            const addItems = syncQueue.filter(item => !item.action || item.action === "ADD");
            const updateItems = syncQueue.filter(item => item.action && item.action !== "ADD");

            if (addItems.length > 0) {
              const res = await postGAS({ action: "BATCH_SYNC", transactions: addItems, deviceToken: getDeviceToken() });
              if (res.result !== "success") throw new Error(res.message || "批次同步失敗");
            }
            
            for (const item of updateItems) {
              const res = await postGAS({ ...item, deviceToken: getDeviceToken() });
              if (res.result !== "success") throw new Error(res.message || "同步失敗");
            }
            setSyncQueue([]);
            didWrite = true;
          }

          if (didWrite) {
              await new Promise(r => setTimeout(r, 800));
          }
          await fetchCloudTx();
          if (!isLoginSync && didWrite) showStatus("success", "同步完成");

          return true; 
        } catch (e) {
          const msg = e.message || "同步失敗"; showStatus("error", msg);
          if (msg.includes("過期") || msg.includes("無效") || msg.includes("憑證") || msg.includes("重新綁定")) {
             forceReloginForToken();
             return false; 
          }
          return true; 
        } finally { 
          if (!isLoginSync) setLoadingCard({ show: false, text: "" }); 
        }
      };

      const handleSaveGreeting = async () => {
         if (!isOnline || !deviceValid()) { showStatus("error", "需連線才能儲存問候語"); return; }
         try {
            setLoadingCard({ show:true, text:"正在儲存..." }); await refreshDeviceToken();
            const res = await postGAS({ action: "UPDATE_GREETING", name: currentUser.name, greeting: customSubtitle, deviceToken: getDeviceToken() });
            if (res.result !== "success") throw new Error(res.message);
            setGreetingsCache(prev => ({...prev, [currentUser.name]: customSubtitle}));
            showStatus("success", "問候語已更新");
         } catch (e) { showStatus("error", e.message || "儲存失敗"); } finally { setLoadingCard({ show:false, text:"" }); }
      };

      const saveLocalPinHash = async (name, pin) => { const h = await sha256Base64(`${name}::${pin}::local`); localStorage.setItem(LS.pinHashPrefix + name, h); };
      const unlockWithPinLocal = async (name, pin) => { const stored = localStorage.getItem(LS.pinHashPrefix + name); if (!stored) return false; const h = await sha256Base64(`${name}::${pin}::local`); return h === stored; };

      const handleBioLoginLocal = async (name) => {
        const lockedUntil = getBioLockedUntil(name);
        if (lockedUntil && Date.now() < lockedUntil) {
          showStatus("error", `請稍候 ${Math.ceil((lockedUntil - Date.now())/1000)}s 再試（剩餘 ${Math.max(0, BIO_MAX_FAIL - getBioFailCount(name))} 次）`); return false;
        }
        try {
          const base64Id = localStorage.getItem(getBioKey(name)); if (!base64Id) { showStatus("error","設備未綁定"); return false; }
          const idStr = atob(base64Id); const idArray = new Uint8Array(idStr.length); for (let i=0;i<idStr.length;i++) idArray[i] = idStr.charCodeAt(i);
          const challenge = new Uint8Array(32); window.crypto.getRandomValues(challenge);
          await navigator.credentials.get({ publicKey: { challenge, allowCredentials: [{ type:"public-key", id:idArray }], userVerification: "required" } });
          clearBioFail(name); return true;
        } catch (e) {
          const fail = getBioFailCount(name) + 1; setBioFailCount(name, fail); const left = Math.max(0, BIO_MAX_FAIL - fail);
          if (left <= 0) { setBioLockedUntil(name, Date.now() + 30000); showStatus("error", `驗證失敗，已暫停 30 秒（剩餘 0 次）`); } else { setBioLockedUntil(name, Date.now() + BIO_COOLDOWN_MS); showStatus("error", `驗證失敗，剩餘 ${left} 次（${Math.ceil(BIO_COOLDOWN_MS/1000)}s 後可再試）`); }
          return false;
        }
      };

      const bindDeviceBio = async () => {
        if (!window.PublicKeyCredential) { showStatus("error","不支援生物辨識"); return; }
        try {
          setLoadingCard({ show:true, text:"正在綁定設備..." });
          const challenge = new Uint8Array(32); crypto.getRandomValues(challenge); const userID = new Uint8Array(16); crypto.getRandomValues(userID);
          const cred = await navigator.credentials.create({ publicKey: { challenge, rp: { name:"家庭記帳" }, user: { id:userID, name: currentUser.name, displayName: currentUser.name }, pubKeyCredParams: [{ type:"public-key", alg:-7 }, { type:"public-key", alg:-257 }], authenticatorSelection: { authenticatorAttachment:"platform", userVerification:"required" }, timeout: 60000 } });
          localStorage.setItem(getBioKey(currentUser.name), btoa(String.fromCharCode.apply(null, Array.from(new Uint8Array(cred.rawId)))));
          clearBioFail(currentUser.name); showStatus("success","設備已綁定");
        } catch { showStatus("error","綁定失敗或已取消"); } finally { setLoadingCard({ show:false, text:"" }); }
      };

      const unbindDeviceBio = async () => {
        if (unbindPin.length !== 6) { showStatus("error","請輸入 6 位 PIN"); return; }
        if (!isOnline) { showStatus("error","需連線驗證 PIN 才能解除"); return; }
        if (!deviceValid()) { showStatus("error","雲端憑證已過期，請先綁定雲端"); return; }
        try {
          setLoadingCard({ show:true, text:"正在驗證..." }); await verifyPinOnline(currentUser.name, unbindPin);
          localStorage.removeItem(getBioKey(currentUser.name)); clearBioFail(currentUser.name); setShowUnbindModal(false); setUnbindPin(""); showStatus("success","已解除綁定");
        } catch (e) { showStatus("error", e.message || "PIN 錯誤"); } finally { setLoadingCard({ show:false, text:"" }); }
      };

      const changePin = async () => {
        if (!isOnline) { showStatus("error","需連線才能更換密碼"); return; }
        if (!deviceValid()) { showStatus("error","雲端憑證已過期，請先綁定雲端"); return; }
        if (oldPin.length !== 6 || newPin.length !== 6 || newPin2.length !== 6) { showStatus("error","請輸入 6 位 PIN"); return; }
        if (newPin !== newPin2) { showStatus("error","兩次輸入不一致"); return; }
        try {
          setLoadingCard({ show:true, text:"正在更新密碼..." });
          const res = await postGAS({ action:"UPDATE_PIN", name: currentUser.name, oldPin, newPin, deviceToken: getDeviceToken() });
          if (res.result !== "success") throw new Error(res.message || "更新失敗");
          localStorage.removeItem(LS.pinHashPrefix + currentUser.name); setShowChangePinModal(false);
          showStatus("success","密碼更新成功，請重新登入"); setCurrentUser(null); setSelectingUser(null); setPinInput(""); setActiveTab("dashboard");
        } catch (e) { showStatus("error", e.message || "更新失敗"); } finally { setLoadingCard({ show:false, text:"" }); }
      };

      const handleAdd = async (newTxs) => {
        const baseDate = newTxs[0].date ? newTxs[0].date.replace("T"," ").replace(/-/g,"/") : nowStr();
        const baseTimestamp = Date.now();
        const isMulti = newTxs.length > 1;
        const randomSuffix = () => Math.random().toString(36).substring(2, 8);
        
        const groupId = isMulti ? `G_${baseTimestamp}_${currentUser.name}_${randomSuffix()}` : ""; 
        const parentDesc = isMulti ? newTxs[0].parentDesc : "";

        const completeTxs = newTxs.map((tx, idx) => ({ 
          ...tx, 
          date: baseDate, 
          recorder: currentUser.name, 
          id: `${baseTimestamp + idx}_${currentUser.name}_${randomSuffix()}`, 
          groupId, 
          parentDesc, 
          action: "ADD",
          editHistory: "" 
        }));

        const newList = [...completeTxs, ...transactions];
        setTransactions(newList);
        setTxCache(newList);
        saveToIndexedDB(newList);
        localStorage.setItem(LS.txCache, JSON.stringify(newList));

        if (!isOnline || !deviceValid()) {
          setSyncQueue(prev => [...prev, ...completeTxs]); showStatus("info", `已暫存 ${completeTxs.length} 筆（待同步）`);
          setActiveTab("dashboard"); if (isOnline && !deviceValid()) forceReloginForToken(); return;
        }

        try {
          setLoadingCard({ show:true, text: isMulti ? `寫入 ${completeTxs.length} 筆明細...` : "正在寫入..." }); await refreshDeviceToken();
          
          if (isMulti) {
             const res = await postGAS({ action: "BATCH_SYNC", transactions: completeTxs, deviceToken: getDeviceToken() });
             if (res.result !== "success") throw new Error(res.message || "批次寫入失敗");
          } else {
             const res = await postGAS({ ...completeTxs[0], deviceToken: getDeviceToken() });
             if (res.result !== "success") throw new Error(res.message || "寫入失敗");
          }
          
          await new Promise(r => setTimeout(r, 800));
          await fetchCloudTx(); 
          showStatus("success", isMulti ? `已同步 ${completeTxs.length} 筆紀錄` : "已同步");
        } catch (e) {
          const msg = e.message || "寫入失敗"; 
          setSyncQueue(prev => [...prev, ...completeTxs]);
          if (msg.includes("過期") || msg.includes("無效") || msg.includes("憑證")) { 
             showStatus("error", "憑證已過期，紀錄已暫存"); forceReloginForToken();
          } else { 
             showStatus("error", msg + "，已暫存"); 
          }
        } finally { 
          setLoadingCard({ show:false, text:"" }); 
          setActiveTab("dashboard"); 
        }
      };

      const handleUpdateTx = async (updatedTx) => {
        let finalDateStr = updatedTx.date;
        if (finalDateStr && finalDateStr.includes("T")) {
            finalDateStr = finalDateStr.replace("T"," ").replace(/-/g,"/");
            if (finalDateStr.length > 16) finalDateStr = finalDateStr.slice(0, 16);
        }
        
        const finalUpdatedTx = { ...updatedTx, date: finalDateStr };

        const newList = transactions.map(t => t.id === finalUpdatedTx.id ? { ...t, ...finalUpdatedTx } : t);
        setTransactions(newList);
        setTxCache(newList);
        saveToIndexedDB(newList);
        localStorage.setItem(LS.txCache, JSON.stringify(newList));

        if (editingIsPending) {
          setSyncQueue(prev => prev.map(p => p.id === finalUpdatedTx.id ? { ...p, ...finalUpdatedTx } : p));
          setEditingTx(null); setEditingIsPending(false); showStatus("success","暫存已更新"); return;
        }
        if (!isOnline || !deviceValid()) { 
           showStatus("error","已離線，更新將暫存於手機"); 
           setSyncQueue(prev => [...prev, { ...finalUpdatedTx, action: "UPDATE_TX" }]); 
           setEditingTx(null); setEditingIsPending(false); 
           if (isOnline && !deviceValid()) forceReloginForToken(); 
           return; 
        }
        try {
          setLoadingCard({ show:true, text:"正在更新..." }); await refreshDeviceToken();
          const res = await postGAS({ ...finalUpdatedTx, action:"UPDATE_TX", deviceToken: getDeviceToken() });
          if (res.result !== "success") throw new Error(res.message || "更新失敗");
          
          await new Promise(r => setTimeout(r, 800));
          await fetchCloudTx();
          showStatus("success","已更新");
        } catch (e) {
          const msg = e.message || "更新失敗"; showStatus("error", msg);
          setSyncQueue(prev => [...prev, { ...finalUpdatedTx, action: "UPDATE_TX" }]); 
          if (msg.includes("過期") || msg.includes("無效") || msg.includes("憑證")) forceReloginForToken();
        } finally { 
          setLoadingCard({ show:false, text:"" }); 
          setEditingTx(null); setEditingIsPending(false); 
        }
      };

      const handleUpdateGroupParent = async (groupData) => {
        let finalDateStr = groupData.date;
        if (finalDateStr && finalDateStr.includes("T")) {
            finalDateStr = finalDateStr.replace("T"," ").replace(/-/g,"/");
            if (finalDateStr.length > 16) finalDateStr = finalDateStr.slice(0, 16);
        }

        const newList = transactions.map(t => String(t.groupId) === String(groupData.groupId) ? { ...t, date: finalDateStr, parentDesc: groupData.parentDesc } : t);
        setTransactions(newList);
        setTxCache(newList);
        saveToIndexedDB(newList);
        localStorage.setItem(LS.txCache, JSON.stringify(newList));

        if (!isOnline || !deviceValid()) { 
           showStatus("error","已離線，更新將暫存於手機"); 
           setSyncQueue(prev => [...prev, { ...groupData, date: finalDateStr, action: "UPDATE_GROUP_PARENT" }]); 
           setEditingGroup(null); 
           if (isOnline && !deviceValid()) forceReloginForToken(); 
           return; 
        }
        try {
          setLoadingCard({ show:true, text:"正在更新母項目..." }); await refreshDeviceToken();
          const res = await postGAS({ action:"UPDATE_GROUP_PARENT", groupId: groupData.groupId, parentDesc: groupData.parentDesc, date: finalDateStr, deviceToken: getDeviceToken() });
          if (res.result !== "success") throw new Error(res.message || "更新失敗");
          
          await new Promise(r => setTimeout(r, 800));
          await fetchCloudTx();
          showStatus("success","母項目已更新");
        } catch (e) {
          const msg = e.message || "更新失敗"; showStatus("error", msg);
          setSyncQueue(prev => [...prev, { ...groupData, date: finalDateStr, action: "UPDATE_GROUP_PARENT" }]);
          if (msg.includes("過期") || msg.includes("無效") || msg.includes("憑證")) forceReloginForToken();
        } finally { 
          setLoadingCard({ show:false, text:"" }); setEditingGroup(null); 
        }
      };

      const handleDeleteTx = async (id) => {
        const newList = transactions.filter(t => t.id !== id);
        setTransactions(newList);
        setTxCache(newList);
        saveToIndexedDB(newList);
        localStorage.setItem(LS.txCache, JSON.stringify(newList));

        if (editingIsPending) {
          setSyncQueue(prev => prev.filter(p => p.id !== id)); 
          setEditingTx(null); setEditingIsPending(false); showStatus("success","暫存已刪除"); return;
        }
        if (!isOnline || !deviceValid()) { 
           showStatus("error","已離線，刪除將暫存於手機"); 
           setSyncQueue(prev => [...prev, { id, action: "DELETE_TX" }]); 
           setEditingTx(null); setEditingIsPending(false); 
           if (isOnline && !deviceValid()) forceReloginForToken(); 
           return; 
        }
        try {
          setLoadingCard({ show:true, text:"正在刪除..." }); await refreshDeviceToken();
          const res = await postGAS({ action:"DELETE_TX", id, deviceToken: getDeviceToken() });
          if (res.result !== "success") throw new Error(res.message || "刪除失敗");
          
          await new Promise(r => setTimeout(r, 800));
          await fetchCloudTx();
          showStatus("success","已刪除");
        } catch (e) {
          const msg = e.message || "刪除失敗"; showStatus("error", msg);
          setSyncQueue(prev => [...prev, { id, action: "DELETE_TX" }]); 
          if (msg.includes("過期") || msg.includes("無效") || msg.includes("憑證")) forceReloginForToken();
        } finally { 
          setLoadingCard({ show:false, text:"" }); setEditingTx(null); setEditingIsPending(false); 
        }
      };

      const visibleTransactions = useMemo(() => {
        if (!currentUser) return [];
        return transactions.length ? transactions : txCache;
      }, [currentUser, transactions, txCache]);

      const myTransactions = useMemo(() => {
        if (!currentUser) return [];
        return visibleTransactions.filter(t => t.member === currentUser.name);
      }, [visibleTransactions, currentUser]);

      const stats = useMemo(() => {
        const income = myTransactions.filter(t => t.type === "income").reduce((s,t)=>s+(Number(t.amount)||0),0);
        const expense = myTransactions.filter(t => t.type === "expense").reduce((s,t)=>s+(Number(t.amount)||0),0);
        return { income, expense, balance: income - expense };
      }, [myTransactions]);

      const groupTransactions = (list) => {
        const grouped = []; const groupMap = {};
        for (const tx of list) {
          if (tx.groupId) {
            if (!groupMap[tx.groupId]) {
              const parts = String(tx.parentDesc || "").split("|||");
              const pTitle = parts.length > 1 ? parts[0] : (parts[0] || "拆分紀錄");
              const pDesc = parts.length > 1 ? parts[1] : "";
              groupMap[tx.groupId] = {
                isGroup: true, groupId: tx.groupId, parentTitle: pTitle, parentDesc: pDesc, date: tx.date, timestamp: tx.timestamp,
                member: tx.member, recorder: tx.recorder, type: tx.type, amount: 0, children: []
              };
              grouped.push(groupMap[tx.groupId]);
            }
            groupMap[tx.groupId].children.push(tx);
            groupMap[tx.groupId].amount += Number(tx.amount || 0);
          } else {
            grouped.push({ ...tx, isGroup: false });
          }
        }
        return grouped;
      };

      const parseDateForSort = (item) => {
        if (!item) return 0;
        if (item.timestamp) return item.timestamp;
        if (!item.date) return 0;
        let str = String(item.date).replace(/上午|下午|AM|PM/gi, "").trim().replace(/-/g, "/").replace("T", " ");
        return new Date(str).getTime() || 0;
      };

      const allGroupedAndSorted = useMemo(() => {
        const grouped = groupTransactions(visibleTransactions);
        return grouped.sort((a, b) => {
          const tA = parseDateForSort(a); const tB = parseDateForSort(b);
          if (tB !== tA) return tB - tA;
          const idA = a.isGroup ? a.children[0].id : a.id; const idB = b.isGroup ? b.children[0].id : b.id;
          return (String(idB) || "").localeCompare(String(idA) || ""); 
        });
      }, [visibleTransactions]);

      const filteredHistoryGroups = useMemo(() => {
        if (!currentUser) return [];
        let list = allGroupedAndSorted.filter(item => item.member === currentUser.name);
        if (historyTypeFilter !== "all") list = list.filter(item => item.type === historyTypeFilter);
        if (historyDateFilter !== "all") {
          const now = new Date(); const cutoff = new Date();
          if (historyDateFilter === "7d") cutoff.setDate(now.getDate() - 7);
          else if (historyDateFilter === "14d") cutoff.setDate(now.getDate() - 14);
          else if (historyDateFilter === "1m") cutoff.setMonth(now.getMonth() - 1);
          else if (historyDateFilter === "3m") cutoff.setMonth(now.getMonth() - 3);
          else if (historyDateFilter === "6m") cutoff.setMonth(now.getMonth() - 6);
          else if (historyDateFilter === "1y") cutoff.setFullYear(now.getFullYear() - 1);
          list = list.filter(item => parseDateForSort(item) >= cutoff.getTime());
        }

        const searchTxt = debouncedHistorySearch.trim();
        const dateRangeRegex = /^(\d{4}\/\d{1,2}\/\d{1,2})\s*-\s*(\d{4}\/\d{1,2}\/\d{1,2})$/;
        const match = searchTxt.match(dateRangeRegex);

        if (match) {
